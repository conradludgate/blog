<!doctype html><html lang=en-gb><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=format-detection content="telephone=no"><title>Fast AF Fourier Transform (FafFT) | Conrad Ludgate</title><meta property="og:title" content="Fast AF Fourier Transform (FafFT) | Conrad Ludgate"><meta property="og:image" content="https://conradludgate.com/android-icon-192x192.png"><meta property="og:type" content="blog"><meta property="og:description" content="I recently saw these two videos about the discrete fourier transform (DFT) and discovering the fast fourier transform (FFT) and I got re-inspired to experiment with the FFT algorithm again."><link rel=apple-touch-icon sizes=57x57 href=/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://conradludgate.com/css/main.min.2545a1910010e26a9905276045afab868f812580a1e7482423da6c0c8c214d18.css><script>function analytics(){if(navigator.doNotTrack!==1){let script=document.createElement("script");script.async=true;script.src="https:\/\/api.conradludgate.com\/umami.js";script.setAttribute("data-website-id","84ad2084-1dde-4a04-9f6c-718e3a948f06");document.body.appendChild(script);}}
window.addEventListener("load",analytics);</script></head><body><nav><header><div class=site-title><a href=/>Conrad Ludgate</a></div></header><div class=nav-menu><a class="color-link nav-link" href=/about/>About</a>
<a class="color-link nav-link" href=/tags/>Tags</a>
<a class="color-link nav-link" href=https://conradludgate.com/index.xml target=_blank rel=noopener type=application/rss+xml>RSS</a></div><footer class=footer><div class=social-icons><a class=social-icon href=https://twitter.com/conradludgate target=_blank rel=noopener title=Twitter><svg width="28" height="28" viewBox="0 0 28 28" fill="#ababab" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M8.991284 24.971612c10.189152.0 15.761088-8.441388 15.761088-15.761088C24.752372 8.970656 24.747512 8.731868 24.736496 8.494376 25.818008 7.712564 26.758256 6.737 27.5 5.62622 26.507372 6.067076 25.439252 6.364292 24.318752 6.498212 25.462472 5.812628 26.340512 4.727444 26.754584 3.434036 25.684088 4.068536 24.499004 4.53002 23.23724 4.778528 22.226468 3.701876 20.786828 3.028388 19.193828 3.028388 16.134404 3.028388 13.653536 5.509256 13.653536 8.567492 13.653536 9.0023 13.702244 9.424904 13.797176 9.830552 9.19346 9.599108 5.11106 7.39472 2.3792 4.04294 1.903028 4.861364 1.629032 5.812628 1.629032 6.827072 1.629032 8.74904 2.606972 10.445612 4.094024 11.438132 3.185528 11.41016 2.331788 11.160464 1.585184 10.745096 1.583888 10.768208 1.583888 10.791428 1.583888 10.815728 1.583888 13.49888 3.493652 15.738584 6.028088 16.246508 5.562932 16.373084 5.07326 16.44134 4.56782 16.44134 4.210988 16.44134 3.863876 16.406024 3.526484 16.34144 4.231724 18.542264 6.276596 20.143796 8.701412 20.18894 6.805148 21.674696 4.416836 22.56008 1.821488 22.56008 1.374476 22.56008.93362 22.534592.5 22.4834 2.951708 24.054476 5.862524 24.971612 8.991284 24.971612"/></svg></a><a class=social-icon href=https://www.linkedin.com/in/conrad-ludgate-a78090159/ target=_blank rel=noopener title=LinkedIn><svg width="28" height="28" viewBox="0 0 28 28" fill="#ababab" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M2 3.654102C2 2.69908141 2.79442509 1.92397846 3.77383592 1.92397846H24.2261641C25.2058917 1.92397846 26 2.69908141 26 3.654102V24.3462148C26 25.3015521 25.2058917 26.0760215 24.2261641 26.0760215H3.77383592C2.79442509 26.0760215 2 25.3015521 2 24.3465315V3.65378524 3.654102zM9.27526132 22.1415901V11.2356668H5.65030092V22.1415901H9.27557808 9.27526132zM7.46341463 9.74691162C8.72727273 9.74691162 9.51409566 8.90940767 9.51409566 7.86284447 9.49033893 6.79252455 8.72727273 5.97846056 7.48748812 5.97846056 6.24675325 5.97846056 5.43649034 6.79252455 5.43649034 7.86284447 5.43649034 8.90940767 6.22299652 9.74691162 7.4396579 9.74691162H7.46309788 7.46341463zM11.2815965 22.1415901H14.9062401V16.0519481C14.9062401 15.7263225 14.9299968 15.4000634 15.0256573 15.1675641 15.2876148 14.5159962 15.8840672 13.8416218 16.8856509 13.8416218 18.1970225 13.8416218 18.7218879 14.8416218 18.7218879 16.3078872V22.1415901H22.3465315V15.8885017C22.3465315 12.5388027 20.5584416 10.9800443 18.1735825 10.9800443 16.2182452 10.9800443 15.3595185 12.072854 14.8824834 12.8172315H14.9065569V11.2359835H11.2819132C11.3291099 12.2591067 11.2815965 22.1419069 11.2815965 22.1419069V22.1415901z"/></svg></a><a class=social-icon href=https://github.com/conradludgate target=_blank rel=noopener title=GitHub><svg width="28" height="28" viewBox="0 0 28 28" fill="#ababab" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M13.9988029 1.32087331C6.82105037 1.32087331 1 7.14112562 1 14.3212723 1 20.0649109 4.72454649 24.9370678 9.89038951 26.6560892 10.5408085 26.7757983 10.7778323 26.374374 10.7778323 26.0296121 10.7778323 25.7215609 10.7666595 24.9035493 10.760275 23.8189856 7.14426471 24.6042767 6.38131925 22.0760223 6.38131925 22.0760223 5.78995672 20.5740732 4.93762853 20.1742451 4.93762853 20.1742451 3.75729765 19.3682044 5.02701126 19.3841656 5.02701126 19.3841656 6.33183953 19.4759425 7.01817121 20.7241085 7.01817121 20.7241085 8.17775254 22.7104801 10.0611744 22.1366749 10.8017741 21.8038838 10.919887 20.9643246 11.2558703 20.3913175 11.6269683 20.066507 8.74038491 19.7385043 5.70536235 18.6228163 5.70536235 13.6413251 5.70536235 12.2223743 6.21213051 11.0611968 7.04370914 10.1530044 6.90963504 9.82420367 6.46351945 8.50181809 7.17139875 6.71256734 7.17139875 6.71256734 8.26234691 6.36301702 10.7459099 8.04532771 11.78259 7.75642995 12.8950858 7.61277914 14.000399 7.60719272 15.1049142 7.61277914 16.2166119 7.75642995 17.2548881 8.04532771 19.736855 6.36301702 20.8262071 6.71256734 20.8262071 6.71256734 21.5356825 8.50181809 21.0895669 9.82420367 20.9562909 10.1530044 21.7894656 11.0611968 22.2922435 12.2223743 22.2922435 13.6413251 22.2922435 18.6355852 19.2524325 19.734514 16.3570705 20.0561322 16.8231376 20.4575564 17.2389269 21.2508282 17.2389269 22.4638795 17.2389269 24.2012564 17.2229657 25.603448 17.2229657 26.0296121 17.2229657 26.3775663 17.4575954 26.7821827 18.116793 26.6552912 23.2786458 24.9322794 27 20.0633148 27 14.3212723 27 7.14112562 21.1789496 1.32087331 13.9988029 1.32087331"/></svg></a></div><p><a href=https://github.com/conradludgate/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p><script src=https://conradludgate.com/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww="></script></footer></nav><div id=content class=content-container><h1 class=post-title>Fast AF Fourier Transform (FafFT)</h1><time>December 13, 2020</time>
<span class=duration>15 min read</span><div><p><p>I recently saw these two videos about the <a href="https://www.youtube.com/watch?v=g8RkArhtCc4">discrete fourier transform (DFT)</a> and <a href="https://www.youtube.com/watch?v=h7apO7q16V0">discovering the fast fourier transform (FFT)</a> and I got re-inspired to experiment with the FFT algorithm again.</p><p>If you&rsquo;re not sure what a Fourier Transform is or you&rsquo;re not sure how the DFT or FFT algorithms work, then check out the videos above.</p><p>If you&rsquo;re not so keen on videos, or don&rsquo;t have the time, I&rsquo;ll try to briefly explain it.</p><h2 id=what-is-the-fft>What is the FFT?</h2><p>Before covering FFT, let&rsquo;s first talk about what the Fourier Transform is. It takes an input from &lsquo;signal space&rsquo; and converts it to &lsquo;frequency space&rsquo;. What does that mean? Take a look at the following graphs</p><p><img src=/fft/pure.png alt="pure sine wave and frequency"></p><p>This shows a simple sine wave, and its frequency can be seen in the spike in the frequency space graph, not so interesting yet.</p><p>However, if we were to make our signal a bit more complex, by layering 3 different sine waves on top of each other, we see that the Fourier Transform is still able to extract the unique frequencies</p><p><img src=/fft/noisy.png alt="pure sine wave and frequency"></p><p>There&rsquo;s a lot more that the Fourier Transform can do, check out the <a href=https://en.wikipedia.org/wiki/Fourier_transform>wikipedia article</a> to learn more.</p><p>The Fast Fourier Transform is a very efficient algorithm to compute the Discrete Fourier Transform.</p><h3 id=wait-what-is-the-discrete-fourier-transform>Wait, what is the discrete fourier transform?</h3><p>I&rsquo;ve skipped a bit about the fourier transform, but it&rsquo;s defined as the following complex integral.</p><p><img src=/fft/ft.svg alt="fourier transform integral"></p><p>This is a continuous operation and impractical to work with real world data in a computer. Instead, we want a version which works on discrete data.</p><p>Instead, we can turn the integral into a finite summation</p><p><img src=/fft/dft.svg alt="discrete fourier transform"></p><p>and the same properties will apply. The issue with this formula is that it will have a complexity of <code>O(n^2)</code>. This means that the run time will quadruple as the input length doubles. This is a big deal for sound processing. Typical audio is sampled at 44,100 times per second. This would need 1,944,810,000 calculations for analysing just a second of audio.</p><p>However, because of the symmetric properties of the fourier transform, there happens to be a clever trick we can do. We can split the input, apply the DFT to each half, then combine them. We can do the same trick to these smaller signals. This takes the complexity all the way down to <code>O(n log n)</code>. This theoretically brings the calculations required for the 44100 sample signal down to ~ 680,000. That&rsquo;s almost 3000 times faster.</p><p>Here&rsquo;s what the FFT algorithm looks like written in python (using numpy)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fft</span>(xs):
    n <span style=color:#f92672>=</span> len(xs)

    <span style=color:#75715e># Recursion base case</span>
    <span style=color:#66d9ef>if</span> n <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
        <span style=color:#66d9ef>return</span> xs

    <span style=color:#75715e># Split the input in half</span>
    evens <span style=color:#f92672>=</span> []
    odds  <span style=color:#f92672>=</span> []
    <span style=color:#66d9ef>for</span> k, x <span style=color:#f92672>in</span> enumerate(xs):
        <span style=color:#66d9ef>if</span> k <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
            evens<span style=color:#f92672>.</span>append(x)
        <span style=color:#66d9ef>else</span>:
            odds<span style=color:#f92672>.</span>append(x)

    <span style=color:#75715e># Apply smaller FFTs</span>
    evens <span style=color:#f92672>=</span> fft(evens)
    odds  <span style=color:#f92672>=</span> fft(odds)

    <span style=color:#75715e># Combine FFTs</span>
    output <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>] <span style=color:#f92672>*</span> n
    <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(n<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>):
        z <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>exp(<span style=color:#f92672>-</span><span style=color:#ae81ff>2j</span> <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>pi <span style=color:#f92672>*</span> k <span style=color:#f92672>/</span> n)
        output[k]        <span style=color:#f92672>=</span> evens[k] <span style=color:#f92672>+</span> z <span style=color:#f92672>*</span> odds[k]
        output[k <span style=color:#f92672>+</span> n<span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> evens[k] <span style=color:#f92672>-</span> z <span style=color:#f92672>*</span> odds[k]

    <span style=color:#66d9ef>return</span> output
</code></pre></div><h2 id=how-can-we-speed-this-up-some-more>How can we speed this up some more?</h2><p>As far as I am aware, there&rsquo;s no way to speed up the algorithm further than <code>O(n log n)</code>, so instead, we have to use some programming optimisations.</p><p>I&rsquo;m going to be writing this implementation in <a href=https://www.rust-lang.org/learn>Rust</a>. Don&rsquo;t worry too much if you&rsquo;re not familiar, I&rsquo;ll explain it as we go.</p><p>The first thing which I want to optimise is the recursion. Recursion is useful and clever and provides very simple solutions to some complex problems, but it ends up being quite slow. Every time you call a function, you push more data onto &lsquo;the stack&rsquo;. The stack controls the data that you will be using regularly. This includes the input variables, any new variables you create in the function, as well as where you will return to once the function is done. This adds up quite considerably with recursive functions.</p><p>How can we possible make this non-recursive? It turns out that <a href=https://en.wikipedia.org/wiki/Primitive_recursive_function>most simple recursive functions</a> can be written iteratively. Let&rsquo;s dry run out FFT above with a small input to see what happens</p><ol><li>Let&rsquo;s take the input <code>[0, 1, 2, 3, 4, 5, 6, 7]</code> with <code>n = 8</code>.</li><li>First, we split input in half. We get <code>es=[0, 2, 4, 6]</code> and <code>os=[1, 3, 5, 7]</code>.</li><li>We then apply the FFT to <code>es</code>. <code>n = 4</code></li><li>We split the input in half again, <code>[0, 4]</code> and <code>[2, 6]</code> respectively.</li><li>We then apply FFT again to <code>[0, 4]</code>, now <code>n = 2</code>.</li><li>Again, we split this in half, <code>[0]</code>, <code>[4]</code>. Since these are our base cases, we can stop here.</li><li>Now that they&rsquo;re split, we can combine the two outputs.</li></ol><p>Ok, let&rsquo;s pause here. We split the input in half 3 times before getting down to the base case, then we combine them back up again at the end. Let&rsquo;s try something different.</p><h3 id=splitting-the-input>Splitting the input</h3><p>Let&rsquo;s instead try to split up the entire input before doing any combining.</p><ul><li><code>[0, 2, 4, 6], [1, 3, 5, 7]</code></li><li><code>[0, 4], [2, 6], [1, 5], [3, 7]</code></li><li><code>[0], [4], [2], [6], [1], [5], [3], [7]</code></li></ul><p>We can then combine them back up just the same as before. We might notice though that we&rsquo;ve not actually required any more space. We&rsquo;ve just re-arranged our input. Let&rsquo;s zip it up back into a single array</p><p><code>[0, 4, 2, 6, 1, 5, 3, 7]</code></p><p>Much simpler. The even terms will just be moved to the left side and the odd terms will be moved to the right.</p><p>Let&rsquo;s take a look at what we have so far.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// This code splits the input in two
</span><span style=color:#75715e>// storing the even indices in the left side of the output
</span><span style=color:#75715e>// and the odd indices in the right side.
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>split_even_odd</span><span style=color:#f92672>&lt;</span>T: Copy<span style=color:#f92672>&gt;</span>(input: <span style=color:#66d9ef>&amp;</span>[T], output: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [T]) {
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> input.len();
    <span style=color:#66d9ef>let</span> n2 <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>for</span> k <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n2 {
        output[k]      <span style=color:#f92672>=</span> input[k <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>];
        output[k <span style=color:#f92672>+</span> n2] <span style=color:#f92672>=</span> input[k <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
    }
}

<span style=color:#75715e>// Compute the FFT over an array of complex values
</span><span style=color:#75715e>// The complex type comes from num_complex
</span><span style=color:#75715e>// https://docs.rs/num-complex/0.3.1/num_complex/struct.Complex.html
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fft</span>(<span style=color:#66d9ef>mut</span> input: Vec<span style=color:#f92672>&lt;</span>Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;</span> {
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> input.len();

    <span style=color:#75715e>// Create a new array with the same length as the input
</span><span style=color:#75715e></span>    <span style=color:#75715e>// This will be where we store the split input
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> split <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[Complex::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>); n];

    <span style=color:#75715e>// Start with our scope over the entire array
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> m <span style=color:#f92672>=</span> n;
    <span style=color:#66d9ef>while</span> m <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> {
        <span style=color:#75715e>// Range over the length of the array, stepping by m each time
</span><span style=color:#75715e></span>        <span style=color:#75715e>// Ex: (n = 8)
</span><span style=color:#75715e></span>        <span style=color:#75715e>//  when m = 8, s takes on the values [0]
</span><span style=color:#75715e></span>        <span style=color:#75715e>//  when m = 4, s takes on the values [0, 4]
</span><span style=color:#75715e></span>        <span style=color:#75715e>//  when m = 2, s takes on the values [0, 2, 4, 6]
</span><span style=color:#75715e></span>        <span style=color:#75715e>// These values point to the start of each sub array
</span><span style=color:#75715e></span>        <span style=color:#75715e>// With m being the length of each sub array.
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> s <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span>..n).step_by(m) {
            split_even_odd(<span style=color:#f92672>&amp;</span>input[s..s<span style=color:#f92672>+</span>m], <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> split[s..s<span style=color:#f92672>+</span>m]);
        }

        <span style=color:#75715e>// Swap the variables so that we can perform the split
</span><span style=color:#75715e></span>        <span style=color:#75715e>// over our new values
</span><span style=color:#75715e></span>        swap(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> input, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> split);

        <span style=color:#75715e>// Narrow the scope over which we split
</span><span style=color:#75715e></span>        m <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;

        <span style=color:#75715e>// Once m is 1, we&#39;re done
</span><span style=color:#75715e></span>    }

    <span style=color:#75715e>// The input variable is now split down to the base case
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>}
</code></pre></div><p>Great! We&rsquo;ve successfully split our input all the way down to the base case iteratively. As you can see, the implementation is already a lot more complex. That&rsquo;s why recursion is so nice conceptually. Anyway, let&rsquo;s continue.</p><h3 id=zipping-back-up>Zipping back up</h3><p>Now that we&rsquo;ve split the input, we need to combine the values back up.</p><p>This actually follows a very similar pattern to above, we just do it backwards. So we start with <code>m = 2</code> and work our way up to <code>m = n</code>, combining the inputs at each step. Let&rsquo;s see what that looks like</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>split_even_odd</span><span style=color:#f92672>&lt;</span>T: Copy<span style=color:#f92672>&gt;</span>(input: <span style=color:#66d9ef>&amp;</span>[T], output: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [T]) { <span style=color:#75715e>/* ... */</span> }

<span style=color:#75715e>// Perform the combine step in-place
</span><span style=color:#75715e>// This saves on us having to allocate more memory
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>combine</span>(input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;</span>]) {
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> input.len();
    <span style=color:#66d9ef>const</span> step: <span style=color:#66d9ef>f64</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> std::<span style=color:#66d9ef>f64</span>::consts::PI <span style=color:#f92672>/</span> (n <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>);

    <span style=color:#66d9ef>for</span> k <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> {
        <span style=color:#75715e>// This is the same as our complex exponential
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> z <span style=color:#f92672>=</span> Complex::from_polar(<span style=color:#ae81ff>1.0</span>, (k <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>) <span style=color:#f92672>*</span> step);

        <span style=color:#75715e>// store as temporary variables since we will
</span><span style=color:#75715e></span>        <span style=color:#75715e>// be overwriting them next step
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> e <span style=color:#f92672>=</span> input[k];
        <span style=color:#66d9ef>let</span> o <span style=color:#f92672>=</span> input[k <span style=color:#f92672>+</span> n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>];

        <span style=color:#75715e>// combine the variables above and store them as our output
</span><span style=color:#75715e></span>        input[k]       <span style=color:#f92672>=</span> e <span style=color:#f92672>+</span> z <span style=color:#f92672>*</span> o;
        input[k <span style=color:#f92672>+</span> n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> e <span style=color:#f92672>-</span> z <span style=color:#f92672>*</span> o;
    }
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fft</span>(<span style=color:#66d9ef>mut</span> input: Vec<span style=color:#f92672>&lt;</span>Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;</span> {
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> input.len();

    <span style=color:#75715e>// split our input all the way down
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> split <span style=color:#f92672>=</span> vec<span style=color:#f92672>!</span>[Complex::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>); n];
    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> m <span style=color:#f92672>=</span> n;
    <span style=color:#66d9ef>while</span> m <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> {
        <span style=color:#66d9ef>for</span> s <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span>..n).step_by(m) {
            split_even_odd(<span style=color:#f92672>&amp;</span>input[s..s<span style=color:#f92672>+</span>m], <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> split[s..s<span style=color:#f92672>+</span>m]);
        }
        swap(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> input, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> split);
        m <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;
    }

    <span style=color:#75715e>// combine our input all the way back up
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> m <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>while</span> m <span style=color:#f92672>&lt;=</span> n {
        <span style=color:#66d9ef>for</span> s <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span>..n).step_by(m) {
            combine(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> input[s..s<span style=color:#f92672>+</span>m]);
        }

        m <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
    }
}
</code></pre></div><p>Awesome! We&rsquo;ve successfully removed the recursion from the FFT! This should be considerably faster. Not only as we not polluting our stack nearly as much, we&rsquo;re not allocating as many arrays either. Let&rsquo;s see where we can go from here.</p><h3 id=caching-values>Caching values</h3><p>One thing you might have noticed is that we&rsquo;re recalculating the value <code>z</code> for every call to <code>combine</code>. This is a bit wasteful. If we can re-use those values, then we would be able to speed up our computation a bit. Starting from the <code>m = 2</code> case, what values of <code>z</code> do we calculate?</p><p>Since <code>k in 0..1</code>, we get <code>exp(-2pi * 0/m) == 1.0</code>.</p><p>How about <code>m = 4</code>. This is a little more interesting, we calculate two values now, <code>[exp(-2pi * 0/m), exp(-2pi * 1/m)] == [1.0, -i]</code></p><p>For <code>m = 8</code>. This is a little more interesting, we get <code>[1.0, 1.41-1.41i, -i, -1.41-1.41i]</code>. Conveniently, the values for the smaller <code>m = 4</code> case are interspersed in the values for <code>m = 8</code>. This simplifies it a lot for us since we can calculate just a single array of our <code>z</code> values, and use them for all of the <code>combine</code> calculations.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// Perform the combine step in-place
</span><span style=color:#75715e>// This saves on use having to allocate more memory
</span><span style=color:#75715e>// Takes in pre-calculated z values
</span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>combine</span>(zs: <span style=color:#66d9ef>&amp;</span>[Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;</span>], input: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> [Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;</span>]) {
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> input.len();
    <span style=color:#66d9ef>let</span> z_step <span style=color:#f92672>=</span> zs.len() <span style=color:#f92672>/</span> n;

    <span style=color:#66d9ef>for</span> k <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> {
        <span style=color:#66d9ef>let</span> z <span style=color:#f92672>=</span> zs[k <span style=color:#f92672>*</span> z_step];

        <span style=color:#66d9ef>let</span> e <span style=color:#f92672>=</span> input[k];
        <span style=color:#66d9ef>let</span> o <span style=color:#f92672>=</span> input[k <span style=color:#f92672>+</span> n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>];
        input[k]       <span style=color:#f92672>=</span> e <span style=color:#f92672>+</span> z <span style=color:#f92672>*</span> o;
        input[k <span style=color:#f92672>+</span> n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> e <span style=color:#f92672>-</span> z <span style=color:#f92672>*</span> o;
    }
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fft</span>(<span style=color:#66d9ef>mut</span> input: Vec<span style=color:#f92672>&lt;</span>Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;</span> {
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> input.len();

    <span style=color:#75715e>// split our input all the way down
</span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// calculate z values
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> step <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> std::<span style=color:#66d9ef>f64</span>::consts::PI <span style=color:#f92672>/</span> (n <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>);
    <span style=color:#75715e>// iterate over the range of values 0 to n/2
</span><span style=color:#75715e></span>    <span style=color:#75715e>// mapping every value to it&#39;s z value
</span><span style=color:#75715e></span>    <span style=color:#75715e>// collecting the results into a vector
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> zs: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>..n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
        .into_iter()
        .map(<span style=color:#f92672>|</span>k<span style=color:#f92672>|</span> Complex::from_polar(<span style=color:#ae81ff>1.0</span>, (k <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>) <span style=color:#f92672>*</span> step))
        .collect();

    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> m <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>while</span> m <span style=color:#f92672>&lt;=</span> n {
        <span style=color:#66d9ef>for</span> s <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span>..n).step_by(m) {
            <span style=color:#75715e>// pass in pre-calculated z values
</span><span style=color:#75715e></span>            combine(<span style=color:#f92672>&amp;</span>zs, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> input[s..s<span style=color:#f92672>+</span>m]);
        }

        m <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
    }
}
</code></pre></div><p>That&rsquo;s better. And considerably faster. A big part of the FFT algorithm is computing those complex values, so now that we only have to do it once is a great improvement.</p><p>Now, as far as I am aware, that&rsquo;s as fast as we can get with the combine step. We are forced by the algorithm to make this many computations. There might be some tricks with cache lines but that&rsquo;s the edge of my knowledge.</p><p>However, let&rsquo;s look back to the splitting stage. Let&rsquo;s see if we can speed that up some more.</p><h3 id=the-cherry-on-top>The Cherry on top</h3><p>For our <code>n = 8</code> example, let&rsquo;s see how many times we need to copy data.</p><ol><li><code>input = [0, 1, 2, 3, 4, 5, 6, 7]</code></li><li><code>allocate array with capacity 8</code></li><li><code>copy the 8 values to [0, 2, 4, 6, 1, 3, 5, 7]</code></li><li><code>copy the 8 values to [0, 4, 2, 6, 1, 5, 3, 7]</code></li><li><code>copy the 8 values to [0, 4, 2, 6, 1, 5, 3, 7]</code></li></ol><p>We ended up using 24 copies and allocating <code>8 * 2 * 64</code> bytes for temporary use. However, if you&rsquo;ve been paying close attention, you might notice that the last step was useless. So we can get rid of 8 of those copies. If you&rsquo;ve been paying really close attention, you may notice that we actually only need 2 swaps!</p><ol start=0><li><code>[0, 1, 2, 3, 4, 5, 6, 7]</code></li><li><code>[0, 4, 2, 3, 1, 5, 6, 7] swap(1, 4)</code></li><li><code>[0, 4, 2, 6, 1, 5, 3, 7] swap(3, 6)</code></li></ol><p>That&rsquo;s it. That&rsquo;s all we needed to get split our data. No allocations either.</p><p>Let&rsquo;s cover a bigger example. <code>n = 16</code></p><p><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]</code> =></p><p><code>[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]</code></p><ol start=0><li><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]</code></li><li><code>[0, 8, 2, 3, 4, 5, 6, 7, 1, 9, 10, 11, 12, 13, 14, 15] swap(1, 8)</code></li><li><code>[0, 8, 4, 3, 2, 5, 6, 7, 1, 9, 10, 11, 12, 13, 14, 15] swap(2, 4)</code></li><li><code>[0, 8, 4, 12, 2, 5, 6, 7, 1, 9, 10, 11, 3, 13, 14, 15] swap(3, 12)</code></li><li><code>[0, 8, 4, 12, 2, 10, 6, 7, 1, 9, 5, 11, 3, 13, 14, 15] swap(5, 10)</code></li><li><code>[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 11, 3, 13, 7, 15] swap(7, 14)</code></li><li><code>[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] swap(11, 13)</code></li></ol><p>6 Swaps for <code>n = 6</code>! However, how do we know which swaps to make?</p><p>Let&rsquo;s take this <code>0..16</code> shuffle output and number them. Let&rsquo;s see if we spot anything interesting.</p><ul><li><code>0 => 0</code></li><li><code>1 => 8</code></li><li><code>2 => 4</code></li><li><code>3 => 12</code></li><li><code>4 => 2</code></li><li><code>5 => 10</code></li><li><code>6 => 6</code></li><li><code>7 => 14</code></li><li><code>8 => 1</code></li><li><code>9 => 9</code></li><li><code>10 => 5</code></li><li><code>11 => 13</code></li><li><code>12 => 3</code></li><li><code>13 => 11</code></li><li><code>14 => 7</code></li><li><code>15 => 15</code></li></ul><p>Hmm. Let&rsquo;s remove the fixed points and the duplicates</p><ul><li><code>1 => 8</code></li><li><code>2 => 4</code></li><li><code>3 => 12</code></li><li><code>5 => 10</code></li><li><code>7 => 14</code></li><li><code>11 => 13</code></li></ul><p>Wait a minute, that&rsquo;s exactly the swaps we made. If we can figure out how to generate this shuffled <code>0..16</code> quickly and filter out all the fixed points and duplicates, then we know exactly what values we need to swap.</p><p>Let&rsquo;s see this 0..16 shuffled array one more time.</p><p><code>[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]</code></p><p>Can you spot the pattern? If you&rsquo;re into puzzles, I would stop reading here and try to figure it out. There&rsquo;s a direct mapping between <code>0..16</code> to these numbers.</p><p>Since this algorithm involves a lot of 2s (evens and odds, halving and doubling), let&rsquo;s convert these numbers to binary</p><ul><li><code>0 => 0000</code></li><li><code>8 => 1000</code></li><li><code>4 => 0100</code></li><li><code>12 => 1100</code></li><li><code>2 => 0010</code></li><li><code>10 => 1010</code></li><li><code>6 => 0110</code></li><li><code>14 => 1110</code></li><li><code>1 => 0001</code></li><li><code>09 => 1001</code></li><li><code>05 => 0101</code></li><li><code>13 => 1101</code></li><li><code>03 => 0011</code></li><li><code>11 => 1011</code></li><li><code>07 => 0111</code></li><li><code>15 => 1111</code></li></ul><p>If you were to take a mirror to these numbers, you might spot it.</p><p>It turns out that these numbers are just the numbers 0 through 15 with their bits flipped!</p><p>Removing the fixed points and duplicates turns out to be very easy. If the index the value maps to is more than the index, then we accept that as a valid swap. Otherwise we ignore it.</p><p>Let&rsquo;s see what this looks like in code</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fft</span>(<span style=color:#66d9ef>mut</span> input: Vec<span style=color:#f92672>&lt;</span>Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;</span>) -&gt; Vec<span style=color:#f92672>&lt;</span>Complex<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;</span> {
    <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> input.len();

    <span style=color:#75715e>// For 64bit usize and n = 16 (4 bits),
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Since reverse_bits reverses the entire value,
</span><span style=color:#75715e></span>    <span style=color:#75715e>// we need to shift back 60 spaces
</span><span style=color:#75715e></span>    <span style=color:#75715e>// If n = 16, n-1 = 15, which has 60 leading zeros.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> shift <span style=color:#f92672>=</span> (n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>).leading_zeros();
    <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span>..n {
        <span style=color:#66d9ef>let</span> j <span style=color:#f92672>=</span> i.reverse_bits() <span style=color:#f92672>&gt;&gt;</span> shift;
        <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> j {
            input.swap(i, j);
        }
    }

    <span style=color:#66d9ef>let</span> step <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2.0</span> <span style=color:#f92672>*</span> std::<span style=color:#66d9ef>f64</span>::consts::PI <span style=color:#f92672>/</span> (n <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>);
    <span style=color:#66d9ef>let</span> zs: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>..n<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>)
        .into_iter()
        .map(<span style=color:#f92672>|</span>k<span style=color:#f92672>|</span> Complex::from_polar(<span style=color:#ae81ff>1.0</span>, (k <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>f64</span>) <span style=color:#f92672>*</span> step))
        .collect();

    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> m <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>while</span> m <span style=color:#f92672>&lt;=</span> n {
        <span style=color:#66d9ef>for</span> s <span style=color:#66d9ef>in</span> (<span style=color:#ae81ff>0</span>..n).step_by(m) {
            combine(<span style=color:#f92672>&amp;</span>zs, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> input[s..s<span style=color:#f92672>+</span>m]);
        }
        m <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
    }
}
</code></pre></div><p>That&rsquo;s it! A wonderfully fast and space efficient implementation of the FFT algorithm. There may be a few more optimisations here and there, but this ends up being about 5 times faster than the naive implementation on my hardware.</p><h2 id=caveats-and-conclusion>Caveats and Conclusion</h2><p>What I&rsquo;ve been referring to as the FFT is actually the <a href=https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm>Cooley-Tukey Radix-2 FFT algorithm</a>. It only works with input lengths that are a power of two. The recursive algorithm for FFT works for non powers of two, but once you get to a half down to a non-even input length, you use the standard DFT algorithm. If you can, padding your input to the next power of two can often be the fastest method.</p><p>The reversed bit swapping method mentioned above is known as the <a href=https://en.wikipedia.org/wiki/Bit-reversal_permutation>Bit-reversal permutation</a> and is discussed in the FFT article. Turns out that I&rsquo;m not the only person to have figured this out, albeit I am not at all surprised. It was quite a thrill when I figured it out myself.</p><p>Anyway, this was a very fun exercise to experiment with optimising this algorithm and to write this post.</p></p></div><div class=page-footer><hr class=footer-divider><a class=tag href=/tags/dev>#dev</a>
<a class=tag href=/tags/rust>#rust</a>
<a class=tag href=/tags/maths>#maths</a></div><link rel=stylesheet type=text/css href=/css/katex.min.css><script type=text/javascript src=/js/katex.min.js></script><script type=text/javascript src=/js/auto-render.min.js onload=renderMathInElement(document.body);></script></div><footer class=footer-mobile><div class=social-icons><a class=social-icon href=https://twitter.com/conradludgate target=_blank rel=noopener title=Twitter><svg width="28" height="28" viewBox="0 0 28 28" fill="#ababab" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M8.991284 24.971612c10.189152.0 15.761088-8.441388 15.761088-15.761088C24.752372 8.970656 24.747512 8.731868 24.736496 8.494376 25.818008 7.712564 26.758256 6.737 27.5 5.62622 26.507372 6.067076 25.439252 6.364292 24.318752 6.498212 25.462472 5.812628 26.340512 4.727444 26.754584 3.434036 25.684088 4.068536 24.499004 4.53002 23.23724 4.778528 22.226468 3.701876 20.786828 3.028388 19.193828 3.028388 16.134404 3.028388 13.653536 5.509256 13.653536 8.567492 13.653536 9.0023 13.702244 9.424904 13.797176 9.830552 9.19346 9.599108 5.11106 7.39472 2.3792 4.04294 1.903028 4.861364 1.629032 5.812628 1.629032 6.827072 1.629032 8.74904 2.606972 10.445612 4.094024 11.438132 3.185528 11.41016 2.331788 11.160464 1.585184 10.745096 1.583888 10.768208 1.583888 10.791428 1.583888 10.815728 1.583888 13.49888 3.493652 15.738584 6.028088 16.246508 5.562932 16.373084 5.07326 16.44134 4.56782 16.44134 4.210988 16.44134 3.863876 16.406024 3.526484 16.34144 4.231724 18.542264 6.276596 20.143796 8.701412 20.18894 6.805148 21.674696 4.416836 22.56008 1.821488 22.56008 1.374476 22.56008.93362 22.534592.5 22.4834 2.951708 24.054476 5.862524 24.971612 8.991284 24.971612"/></svg></a><a class=social-icon href=https://www.linkedin.com/in/conrad-ludgate-a78090159/ target=_blank rel=noopener title=LinkedIn><svg width="28" height="28" viewBox="0 0 28 28" fill="#ababab" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M2 3.654102C2 2.69908141 2.79442509 1.92397846 3.77383592 1.92397846H24.2261641C25.2058917 1.92397846 26 2.69908141 26 3.654102V24.3462148C26 25.3015521 25.2058917 26.0760215 24.2261641 26.0760215H3.77383592C2.79442509 26.0760215 2 25.3015521 2 24.3465315V3.65378524 3.654102zM9.27526132 22.1415901V11.2356668H5.65030092V22.1415901H9.27557808 9.27526132zM7.46341463 9.74691162C8.72727273 9.74691162 9.51409566 8.90940767 9.51409566 7.86284447 9.49033893 6.79252455 8.72727273 5.97846056 7.48748812 5.97846056 6.24675325 5.97846056 5.43649034 6.79252455 5.43649034 7.86284447 5.43649034 8.90940767 6.22299652 9.74691162 7.4396579 9.74691162H7.46309788 7.46341463zM11.2815965 22.1415901H14.9062401V16.0519481C14.9062401 15.7263225 14.9299968 15.4000634 15.0256573 15.1675641 15.2876148 14.5159962 15.8840672 13.8416218 16.8856509 13.8416218 18.1970225 13.8416218 18.7218879 14.8416218 18.7218879 16.3078872V22.1415901H22.3465315V15.8885017C22.3465315 12.5388027 20.5584416 10.9800443 18.1735825 10.9800443 16.2182452 10.9800443 15.3595185 12.072854 14.8824834 12.8172315H14.9065569V11.2359835H11.2819132C11.3291099 12.2591067 11.2815965 22.1419069 11.2815965 22.1419069V22.1415901z"/></svg></a><a class=social-icon href=https://github.com/conradludgate target=_blank rel=noopener title=GitHub><svg width="28" height="28" viewBox="0 0 28 28" fill="#ababab" xmlns="https://www.w3.org/2000/svg" xmlns:xlink="https://www.w3.org/1999/xlink"><path d="M13.9988029 1.32087331C6.82105037 1.32087331 1 7.14112562 1 14.3212723 1 20.0649109 4.72454649 24.9370678 9.89038951 26.6560892 10.5408085 26.7757983 10.7778323 26.374374 10.7778323 26.0296121 10.7778323 25.7215609 10.7666595 24.9035493 10.760275 23.8189856 7.14426471 24.6042767 6.38131925 22.0760223 6.38131925 22.0760223 5.78995672 20.5740732 4.93762853 20.1742451 4.93762853 20.1742451 3.75729765 19.3682044 5.02701126 19.3841656 5.02701126 19.3841656 6.33183953 19.4759425 7.01817121 20.7241085 7.01817121 20.7241085 8.17775254 22.7104801 10.0611744 22.1366749 10.8017741 21.8038838 10.919887 20.9643246 11.2558703 20.3913175 11.6269683 20.066507 8.74038491 19.7385043 5.70536235 18.6228163 5.70536235 13.6413251 5.70536235 12.2223743 6.21213051 11.0611968 7.04370914 10.1530044 6.90963504 9.82420367 6.46351945 8.50181809 7.17139875 6.71256734 7.17139875 6.71256734 8.26234691 6.36301702 10.7459099 8.04532771 11.78259 7.75642995 12.8950858 7.61277914 14.000399 7.60719272 15.1049142 7.61277914 16.2166119 7.75642995 17.2548881 8.04532771 19.736855 6.36301702 20.8262071 6.71256734 20.8262071 6.71256734 21.5356825 8.50181809 21.0895669 9.82420367 20.9562909 10.1530044 21.7894656 11.0611968 22.2922435 12.2223743 22.2922435 13.6413251 22.2922435 18.6355852 19.2524325 19.734514 16.3570705 20.0561322 16.8231376 20.4575564 17.2389269 21.2508282 17.2389269 22.4638795 17.2389269 24.2012564 17.2229657 25.603448 17.2229657 26.0296121 17.2229657 26.3775663 17.4575954 26.7821827 18.116793 26.6552912 23.2786458 24.9322794 27 20.0633148 27 14.3212723 27 7.14112562 21.1789496 1.32087331 13.9988029 1.32087331"/></svg></a></div><div class=footer-mobile-links><p><a href=https://github.com/kimcc/hugo-theme-noteworthy target=_blank rel=noopener>Noteworthy theme</a></p><span class=divider-bar>|</span><p><a href=https://gohugo.io target=_blank rel=noopener>Built with Hugo</a></p></div><script src=https://conradludgate.com/js/main.min.fa5c2b23e07b5d9bfad267a52b4b24fdb053e6fb7524993383594926a3ac270c.js integrity="sha256-+lwrI+B7XZv60melK0sk/bBT5vt1JJkzg1lJJqOsJww="></script></footer></body></html>